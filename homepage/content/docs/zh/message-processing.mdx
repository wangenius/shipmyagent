---
title: 消息处理链路
description: 一条消息进入 ShipMyAgent 后如何被 adapter/runtime 处理，并通过 chat_send/dispatcher 回发（含类型定义）
---

# 消息处理链路（Ingress → Runtime → Reply）

你问的“一个消息进来之后如何处理”，在 ShipMyAgent 里对应的是一条固定链路：**平台入口 → adapter → history 落盘（UIMessage JSONL）→ lane scheduler（按 chatKey 串行）→ Agent.run（每次请求拼 system）→ 工具循环 → chat_send 回发（或 fallback）**。

本文按环节列出关键类型，方便你对照代码定位。

> 约定：本文以 `package/src` 源码为准。

## 0) 调度器（Lane Scheduler）

ShipMyAgent 使用 lane scheduler 按 `chatKey` 隔离调度：

- 同一 `chatKey` 串行（避免同一会话回复交叉/错乱）
- 不同 `chatKey` 可并发（提升整体吞吐）

实现：`package/src/core/runtime/lane-scheduler.ts`。

## 0.1) 默认 system（Agent.md + DefaultPrompt）

从 v2 开始，AgentRuntime 的 system message 由两部分拼成：

- `Agent.md`：项目/仓库的长期指令（人类写给 agent 的规则与偏好）
- `DefaultPrompt`：运行时上下文 + 输出规则（包括要求用 `chat_send` 回发；不允许给 user 文本加前缀）

历史上下文来自该 `chatKey` 的 history（`UIMessage[]`，落盘在 `.ship/chat/<encodedChatKey>/messages/history.jsonl`），并在接近上下文窗口时自动 compact。

## 1) 平台消息进入 adapter

adapter 会把平台原始消息归一化成：

```ts
export type IncomingChatMessage = {
  chatId: string;
  text: string;
  chatType?: string;
  messageId?: string;
  messageThreadId?: number;
  userId?: string;
  username?: string;
};
```

来源：`package/src/adapters/base-chat-adapter.ts`

### `messageId` 是什么？（Telegram 例子）

- `messageId` 是“这条平台消息”的 ID（Telegram 里是 `message_id`，整数，通常在代码里以字符串存）
- 不管是文本/图片/文件/语音，每条消息都有自己的 `message_id`
- 它不是附件的 `file_id`（voice/photo/document 都有独立的 `file_id`，只在 adapter 内部处理附件时使用）

## 2) 计算 chatKey（会话隔离）+ 复用 runtime

`chatKey` 决定“对话历史”和“长期记忆”的隔离粒度；同一个 chatKey 的请求会落到同一份会话上下文里。

相关实现：`package/src/adapters/base-chat-adapter.ts`

### 为什么不总是 `chatKey === chatId`？

- 私聊场景可以这么做，但多平台会撞 key（telegram/qq 都可能是纯数字/字符串）
- 群聊 topic/thread 需要把 `messageThreadId` 纳入 key，否则不同话题上下文会混


## 3) history 落盘（可审计）

用户消息会被 append 到 `.ship/chat/<encodedChatKey>/messages/history.jsonl`（JSONL，一行一条 `UIMessage`）。示例：

```json
{"id":"u:telegram-chat-123:456","role":"user","parts":[{"type":"text","text":"..."}],"metadata":{"v":1,"ts":1730000000000,"channel":"telegram","chatId":"123","chatKey":"telegram-chat-123","userId":"123","messageId":"456"}}
```

相关实现：`package/src/core/history/store.ts` 与 `package/src/types/chat-history.ts`。

## 4) adapter 调用 Agent.run（带上下文）

```ts
export interface AgentRunInput {
  chatKey: string;
  query: string;
}
```

来源：`package/src/types/agent.ts`

平台相关字段（channel/chatId/messageId/threadId/userId/username 等）会由 adapter 在执行时注入到 `ChatRequestContext`，供 `chat_send` 工具回发路由。

> 备注：history 会自动作为 `messages` 注入模型；不需要（也没有）“加载历史”工具。

## 5) 模型通过 chat_send 回发（tool-strict）

`chat_send` 的参数（schema 可当作“类型”使用）：

```ts
{
  text: string;
}
```

来源：`package/src/core/tools/builtin/chat.ts`

`chat_send` 会去 dispatcher registry 找到对应平台的 dispatcher，然后调用 `sendText(...)` 发回平台。

dispatcher 注册点：`package/src/adapters/platform-adapter.ts`

## 6) Fallback：模型忘了 chat_send 时也要把 output 发出去

adapter 会调用 `sendFinalOutputIfNeeded(...)`：
- 如果 toolCalls 里已经有成功的 `chat_send`，就不重复发送
- 否则把 `AgentResult.output` 直接发回平台（避免用户收不到）

实现：`package/src/core/egress/final-output.ts`

## 7) Agent 返回结构

```ts
export interface AgentResult {
  success: boolean;
  output: string;
  toolCalls: Array<{
    tool: string;
    input: Record<string, unknown>;
    output: string;
  }>;
}
```

来源：`package/src/types/agent.ts`

---

更完整的“场景化（Telegram 群聊/topic）+ 调用顺序 + 依赖分层”请看：`docs/message-ingress-and-processing.md`。

当前实现的“简化版运行逻辑（system = Agent.md + DefaultPrompt、无 simulation、按需加载历史）”说明见：`docs/runtime-simplified.md`。
