---
title: 架构
description: ShipMyAgent 系统架构和设计原则
---

# 架构

> ⚠️ **简化模式（2026-02-03）**：当前发布的 `shipmyagent` 包已暂时移除 **Tasks/Runs/Scheduler** 与 **审批（Approvals）**（默认全权限执行）。本文档部分内容可能描述的是旧版/规划中的架构。

深入探讨 ShipMyAgent 的架构、设计决策和技术实现。

## 概述

ShipMyAgent 是作为一个模块化、可扩展的 AI agent 系统构建的，专为本地优先的代码仓库自动化而设计。

```
┌─────────────────────────────────────────────────────────────┐
│                      用户界面                              │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │   CLI        │  │   Telegram   │  │   GitHub     │     │
│  │   界面       │  │   Bot        │  │   集成       │     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘     │
│         │                  │                  │               │
│         └──────────────────┼──────────────────┘               │
│                            │                                  │
│                    ┌───────▼────────┐                         │
│                    │  Agent 核心    │                         │
│                    │  (编排器)      │                         │
│                    └───────┬────────┘                         │
│                            │                                  │
│         ┌──────────────────┼──────────────────┐              │
│         │                  │                  │              │
│    ┌────▼────┐      ┌─────▼─────┐     ┌─────▼─────┐          │
│    │  任务    │      │   LLM     │     │  工具     │          │
│    │  调度器  │      │  提供商   │     │  执行器   │          │
│    └─────────┘      └───────────┘     └───────────┘          │
│                                                               │
└─────────────────────────────────────────────────────────────┘
                            │
                            │
┌───────────────────────────▼──────────────────────────────┐
│                   仓库接口                               │
│  - 文件系统  - Git 操作  - Shell 命令                      │
└────────────────────────────────────────────────────────────┘
```

---

## 核心组件

### 1. Agent 核心（编排器）

管理所有 agent 操作的中央协调器。

**职责**：
- 解析和执行用户命令
- 协调 LLM 和工具交互
- 管理权限检查
- 处理任务调度
- 路由通知
- 管理对话上下文和长期记忆

**关键设计决策**：
- **对话隔离**：每个 chatKey（chat/thread）独立管理上下文
- **基于插件**：工具和 LLM 提供商可插拔
- **权限优先**：所有操作都经过权限检查
- **智能上下文管理**：自动压缩和记忆提取

### 2. LLM 提供商抽象

为多个 LLM 提供商提供统一接口。

**接口**：
```typescript
interface LLMProvider {
  chat(params: ChatParams): Promise<ChatResponse>
  stream(params: ChatParams): AsyncIterator<ChatChunk>
  validate(): Promise<boolean>
  estimateTokens(text: string): number
}
```

**设计好处**：
- 易于添加新提供商
- 故障转移和负载平衡
- 无论提供商如何，API 一致

### 3. 工具系统

可扩展的工具框架，用于 agent 能力。

**内置工具**：
- `read_file`：读取仓库文件
- `write_file`：写入文件
- `exec_shell`：执行 shell 命令
- `s3_upload`：上传项目内文件到 S3 兼容对象存储（含 Cloudflare R2；仅在 `ship.json` 配置了 `oss` 时启用）
- `git_op`：Git 操作
- `search`：搜索代码库

**工具接口**：
```typescript
interface Tool {
  name: string
  description: string
  parameters: ToolParameters
  execute(params: any, context: Context): Promise<ToolResult>
  validate(params: any): boolean
}
```

### 4. 权限系统

安全的细粒度访问控制。

**权限层**：
1. **文件系统**：读/写路径，glob 模式
2. **Shell**：命令白名单/黑名单
3. **网络**：API 端点限制
4. **人工批准**：需要确认的操作

**设计原则**：
- **最小权限**：默认拒绝，显式允许
- **审计跟踪**：所有操作都被记录
- **可撤销**：易于撤销权限

---

## 上下文管理系统

ShipMyAgent 实现了智能的上下文管理机制，确保长对话中的信息不会丢失，同时避免超出 LLM 的上下文限制。

### 架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                   上下文管理系统                            │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  对话运行时  │  │  上下文压缩  │  │  长期记忆    │     │
│  │  (热数据)    │  │  (智能摘要)  │  │  (持久化)    │     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘     │
│         │                  │                  │               │
│         └──────────────────┼──────────────────┘               │
│                            │                                  │
│                    ┌───────▼────────┐                         │
│                    │  对话运行时    │                         │
│                    │  管理器        │                         │
│                    └────────────────┘                         │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 核心组件

#### 1. 对话运行时缓存（按 chatKey）

**功能**：
- 为每个 chatKey 维护独立的内存 `AgentRuntime`
- 快速访问最近的对话上下文
- 对不活跃 chatKey 做 TTL 清理，防止内存泄漏

**工作机制**：
- 每个 chatKey 独立存储，互不干扰
- 不活跃的 chatKey 运行时会在一段时间后自动清理（TTL，best-effort）
- 对话消息通过 `ChatStore` 持久化到磁盘（`.ship/chats/*.jsonl`）

#### 2. 上下文压缩器

**功能**：
- 智能压缩对话历史，避免超出 token 限制
- 支持多种压缩策略

**压缩策略**：

##### 滑动窗口策略
保留最近的 N 条完整消息，丢弃更早的消息。适合对话内容相对独立的场景。

##### 摘要生成策略
为旧消息生成简洁摘要，保留关键信息，然后与最近的完整消息组合。适合需要保留历史上下文的场景。

##### 智能选择策略
根据消息的重要性评分，选择性保留重要消息。评分考虑因素包括：
- 消息的时间位置（越新越重要）
- 消息长度（较长的消息可能包含更多信息）
- 关键词（包含"重要"、"错误"、"决定"等）
- 消息角色（用户消息通常更重要）

**触发时机**：
- **主动压缩**：消息数超过阈值时自动触发
- **被动压缩**：LLM 返回 token 超限错误时触发
- **手动压缩**：用户可通过 API 手动触发

#### 3. 长期记忆系统

**功能**：
- 从对话中提取关键信息并持久化
- 支持多种记忆类型
- 智能去重和重要性评分

**记忆类型**：

| 类型 | 说明 | 示例 |
|------|------|------|
| 偏好 | 用户的使用习惯和偏好 | "用户喜欢简洁的回复" |
| 事实 | 项目相关的重要信息 | "项目使用 TypeScript 开发" |
| 实体 | 人物、项目、组织等 | "张三是项目负责人" |
| 任务 | 待办事项和提醒 | "需要修复登录页面的 bug" |

**提取流程**：
```
对话消息
    │
    ▼
┌─────────────────────────────────┐
│ 1. 频率控制                     │
│    避免频繁提取，节省资源        │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 2. LLM 分析                     │
│    使用 LLM 识别关键信息         │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 3. 去重                         │
│    过滤重复或相似的记忆          │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 4. 持久化                       │
│    保存到本地文件系统            │
└─────────────────────────────────┘
```

### 工作流程

完整的对话处理流程：

```
用户消息
    │
    ▼
┌─────────────────────────────────┐
│ 1. 加载对话上下文               │
│    - 获取历史消息                │
│    - 加载长期记忆                │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 2. 检查是否需要压缩             │
│    根据消息数量和 token 限制     │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 3. 构建完整 Prompt              │
│    组合系统提示、记忆、历史      │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 4. 调用 LLM                     │
│    发送请求并获取响应            │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│ 5. 更新上下文                   │
│    - 保存新消息                  │
│    - 异步提取记忆                │
│    - 清理过期数据                │
└────────────┬────────────────────┘
             │
             ▼
         返回响应
```

### 性能优化

#### 异步处理
记忆提取和数据清理等操作异步执行，不阻塞用户响应，确保快速反馈。

#### 缓存策略
- **内存缓存**：热数据保存在内存中，快速访问
- **文件缓存**：冷数据持久化到磁盘，节省内存

#### 批量处理
支持批量提取记忆，提高处理效率，减少 LLM 调用次数。

### 存储位置

```
.ship/
├── approvals/            # 待审批请求（human-in-the-loop）
│   ├── {approvalId}.json
│   └── ...
├── chats/                # 对话历史（JSONL，append-only）
│   ├── {encode(chatKey)}.jsonl
│   └── ...
├── memory/              # 长期记忆存储
│   ├── {chatKey}.json
│   └── ...
├── .cache/              # 临时缓存（附件、适配器状态等）
└── logs/                # 日志文件
    └── {date}.jsonl
```

### 设计优势

1. **无缝长对话**：自动管理上下文，支持无限长的对话
2. **智能记忆**：自动提取和保存重要信息，无需用户干预
3. **高效压缩**：多种压缩策略，平衡信息保留和性能
4. **对话隔离**：每个 chatKey 独立管理，互不影响
5. **异步优化**：后台处理不影响响应速度

---

## 安全架构

### 威胁模型

**潜在威胁**：
1. **提示注入**：恶意用户试图绕过限制
2. **未授权访问**：Agent 访问敏感资源
3. **代码执行**：运行恶意 shell 命令
4. **数据泄露**：窃取机密或敏感数据

### 缓解策略

#### 1. 权限验证

每个操作都经过检查。

#### 2. 提示清理

在发送到 LLM 之前验证用户输入。

#### 3. 沙箱执行

在受控环境中执行 shell 命令。

#### 4. 审计日志

所有敏感操作都被记录。

---

## 性能考虑

### 优化策略

#### 1. 响应缓存

缓存 LLM 响应以避免重复调用。

#### 2. 流式响应

流式传输 LLM 响应以获得更好的用户体验。

#### 3. 并行工具执行

并行执行独立的工具。

#### 4. 连接池

重用连接以减少开销。

### 性能基准

| 操作 | 时间 | 说明 |
|------|------|------|
| 简单聊天查询 | 1‑3秒 | 取决于 LLM |
| 代码审查（100 行）| 5‑15秒 | 分析整个文件 |
| 文件搜索 | `<1秒` | 使用 ripgrep |
| Shell 命令 | 可变 | 取决于命令 |
| 任务执行 | 10‑60秒 | 复杂任务 |

---

## 可扩展性

### 插件系统

ShipMyAgent 支持自定义工具和提供商。

#### 自定义工具

```typescript
// custom-tool.ts
export class MyCustomTool extends Tool {
  name = 'my_tool';

  async execute(params: { input: string }) {
    // 自定义逻辑
    return {
      success: true,
      data: process(params.input)
    };
  }
}
```

#### 自定义 LLM 提供商

```typescript
// custom-provider.ts
export class CustomLLM extends LLMProvider {
  async chat(params: ChatParams) {
    // 自定义 API 调用
    const response = await fetch(this.baseUrl, {
      method: 'POST',
      body: JSON.stringify(params)
    });
    return await response.json();
  }
}
```

---

## 配置加载

### 配置层次

```
1. ship.json（基础配置）
       ↓
2. 环境变量（覆盖）
       ↓
3. CLI 标志（临时覆盖）
       ↓
4. 运行时配置（最终状态）
```

---

## 错误处理

### 错误类别

1. **用户错误**：无效输入、权限问题
2. **系统错误**：LLM API 失败、网络问题
3. **任务错误**：任务执行失败

---

## 监控和可观测性

### 收集的指标

- **操作计数**：工具使用、任务运行
- **性能**：响应时间、LLM 延迟
- **错误**：失败率、错误类型
- **资源使用**：内存、CPU

### 健康检查

```bash
shipmyagent doctor

# 输出：
✅ 配置：有效
✅ LLM 连接：OK
✅ 文件权限：OK
✅ Git 仓库：OK
⚠️  任务队列：3 个任务失败
✅ 集成状态：全部已连接
```

---

## 可扩展性

### 水平扩展

ShipMyAgent 设计用于单个仓库。对于多个仓库：

```bash
# 运行多个实例
shipmyagent start --project /path/repo1 --port 3000 &
shipmyagent start --project /path/repo2 --port 3001 &
```

### 垂直扩展

对于大型仓库：

```json
{
  "performance": {
    "maxConcurrentTasks": 10,
    "llmPoolSize": 5,
    "cacheSize": "2GB",
    "workerThreads": 4
  }
}
```

---

## 下一步

- [自定义](/docs/customization) - 构建自定义工具和插件
- [API 参考](/docs/reference/api) - 可扩展性 API
- [贡献](/docs/community/contributing) - 架构贡献指南
