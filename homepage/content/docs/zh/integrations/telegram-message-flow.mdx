---
title: Telegram 消息流与执行逻辑
description: 以 Telegram 为例，解释从用户发消息到 Agent 执行，再到回复的端到端数据流
---

# Telegram：从发消息到收到回复的全链路

> ⚠️ **简化模式（2026-02-03）**：当前发布的 `shipmyagent` 包已暂时移除审批（默认全权限执行）。本文档中与审批相关的部分已过期。

这篇文档以 Telegram 为例，说明 **一条用户消息如何进入 ShipMyAgent**，以及 **AgentRuntime 如何执行、以及消息如何通过 `chat_send` tool 发送回 Telegram**。

> 代码参考：`package/src/adapters/telegram/bot.ts`、`package/src/adapters/base-chat-adapter.ts`、`package/src/runtime/agent/runtime.ts`、`package/src/runtime/chat/*`

## 1）总体流程（概览）

```mermaid
sequenceDiagram
  participant U as 用户 (Telegram)
  participant TG as Telegram API
  participant BOT as ShipMyAgent TelegramBot
  participant CS as ChatStore (.ship/chat/*/conversations/*.jsonl)
  participant RT as AgentRuntime
  participant T as chat_send tool

  U->>TG: 发送消息/附件/命令
  BOT->>TG: getUpdates 轮询拉取 update
  TG-->>BOT: update(message/callback_query)

  BOT->>BOT: 解析文本/mention/回复关系/附件
  BOT->>CS: append(user message)
  BOT->>RT: run(instructions)
  RT->>T: chat_send(...)
  T->>TG: sendMessage/附件
```

## 2）输入：Telegram update → “可执行指令”

### 2.1 拉取与分发

- ShipMyAgent 以 **轮询** 模式工作：定时调用 `getUpdates` 拉取 `TelegramUpdate[]`，并更新 `lastUpdateId`（持久化在 `.ship/.cache/telegram/lastUpdateId.json`）。
- 每个 update 会按并发上限处理；同时对**同一个 chatKey**做串行化（避免并发把上下文打乱）。

### 2.2 ChatKey（唯一隔离 key）

ShipMyAgent 会把 Telegram 的聊天抽象为一个 **chatKey**，用来隔离上下文与日志：

- 私聊 / 普通群聊：`telegram:chat:<chatId>`
- Topics（话题）的群：`telegram:chat:<chatId>:topic:<messageThreadId>`

### 2.3 群聊里哪些消息会被处理（mention / reply / follow-up window）

在群聊/超级群中，默认不会“监听所有人所有消息”，而是需要满足下列条件之一：

- **显式触发**：`@bot ...`（mention），或**回复 bot 的消息**（reply-to-bot）
- **跟进窗口**：当你刚刚显式触发过一轮对话，后续短时间内的追问可不再 `@`（follow-up window）

此外还有一层 **可对话人限制（groupAccess）**：

- 默认：仅“该 thread 的发起人（第一个和 bot 说话的人）”或“群管理员”可以继续对话
- 可配置为 `"anyone"`：允许任何群成员对话

发起人信息会写入 `.ship/.cache/telegram/threadInitiators.json`，用 chatKey 作为 key。

### 2.4 附件处理：保存到本地缓存 + 注入 `@attach`

当 message 含附件（document/photo/voice/audio）时，ShipMyAgent 会：

1. 调用 `getFile` 获得 `file_path`，再下载文件内容
2. 写入本地缓存目录：`.ship/.cache/telegram/`
3. 在最终指令文本前拼一段 `@attach ...` 行（相对 `projectRoot` 的路径）

示例（最终送入 AgentRuntime 的 instructions）：

```text
@attach document .ship/.cache/telegram/1738...-xxx.pdf | xxx.pdf

帮我总结这个 PDF，并列出待办事项。
```

> 说明：如果用户在发送文件时写了 caption，caption 会作为“文本指令”的来源（与纯 text 同等对待）。

## 3）持久化：ChatStore 如何记录上下文

每次收到用户消息，TelegramBot 都会先写入一条聊天日志（append-only）：

- 路径：`.ship/chat/<encode(chatKey)>/conversations/history.jsonl`
- 格式：`ChatLogEntryV1`（包含 channel/chatId/chatKey/userId/messageId/role/text/meta 等）

在真正执行之前，runtime 默认使用同一 `chatKey` 的 in-memory session history（不会自动把 `.jsonl` 的历史加载进模型上下文）。当模型需要更多落盘历史细节时，可调用 `chat_load_history` 从 `.ship/chat/<chatKey>/conversations/history.jsonl` 按需读取/搜索并注入到当前上下文。

## 4）执行：AgentRuntime 如何跑起来（sync / async）

### 4.1 tool-strict：由 Agent 主动发消息

ShipMyAgent 的聊天集成采用 tool-strict：

- Agent 通过 `chat_send` 工具把回复发送回 Telegram（可以分多条、按阶段发送）
- 集成本身不再“自动转发 Agent 的输出”为消息（避免把发送逻辑写死在集成层）

### 4.2 执行与回复（run + delivery）

如果不是审批回复，TelegramBot 会直接调用：

- `agentRuntime.run({ instructions, context })`

回复发送遵循 tool-strict：

- **主要路径**：Agent 使用 `chat_send` 工具把消息发送回 Telegram（可以分多条/分阶段）
- **兜底路径**：如果 Agent 忘记调用 `chat_send`，集成会把最终的 plain text `output` 回发（避免“用户收不到回复”）

发送消息时会：

- 按 3900 字符分片（避开 Telegram 4096 限制）
- 优先用 `parse_mode=Markdown`，失败则回退纯文本
- 解析输出中的 `@attach ...` 并以真正的 Telegram 附件形式发送（支持本地路径或 URL）

### 4.3 按需加载历史（可选）

当模型判断当前 in-memory session history 不够时，可以调用 `chat_load_history`，把 `.ship/chat/<chatKey>/conversations/history.jsonl` 中更早的消息加载并注入到当前上下文（插入位置在当前 user 消息之前）。

## 5）用户可能收到的“各种消息”

以一次完整交互为例，用户可能看到：

- **普通回复**：最终答案（可能分片多条；主要来自 `chat_send`，兜底来自 `output` 回发）
- **进度消息**：仅当 Agent 主动用 `chat_send` 发送阶段性进度时才会出现（集成层不做自动“流式转发”）
- （可选）**进度消息**：仅当 Agent 主动用 `chat_send` 发送阶段性进度时才会出现
