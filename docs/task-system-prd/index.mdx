---
id: task-system-prd
title: Task System PRD
---

# Task System（PRD）

## 1. 背景与问题

当前 ShipMyAgent 支持“对话式触发”（用户消息驱动）的 Agent 执行，但缺少一种**可审计的、可定时的、可重复执行的工作单元**。这类需求常见于：

- 每天/每周例行检查（构建、监控、数据拉取、仓库巡检、日报生成等）
- 固定节奏的提醒与同步（把结果推送到指定 chatKey）
- SOP 流程化（以 markdown 方式沉淀为任务正文，随时复用）

因此需要新增 Task 系统：用 markdown + frontmatter 描述任务，用 cron 定时触发，执行过程全量落盘可审计，并把执行结果推送到指定 `chatKey`。

## 2. 目标（Goals）

- **文件即任务**：一个 task 由 `task.md`（含 frontmatter + 正文）定义，落盘在 `./.ship/task/` 下。
- **强审计**：每次执行生成一个 run 目录：`<task_id>/<timestamp>/`，包含执行历史 `history.jsonl` 与过程文件 `*.md`。
- **干净历史执行**：定时触发时从“干净的历史”（空历史/最小 system）开始执行任务正文，避免被历史聊天污染。
- **结果推送**：执行完成后向 `task.md` 的 `chatKey` 发送一条消息（成功/失败都要发，且包含 runId/摘要/路径）。
- **模块化**：Task 系统作为独立模块（核心：存储/解析/调度/执行/工具 API），方便未来扩展。
- **可操作**：提供内置 tools：`create_task`、`task_list`、`run_task`（手动触发），并提供一个内置 Skill 文档解释其使用。

## 3. 非目标（Non-goals）

- 不做“跨项目全局任务”（例如 `~/.ship/task` 被任意 project runtime 执行）——避免语义混乱。
- 不做分布式调度（多实例抢占/去重）；当前以单机单进程 runtime 为主。
- 不做复杂的 UI；以 md 文件 + tool/CLI 为主。

## 4. 术语与核心概念

- **Task**：任务定义；由一个目录 `./.ship/task/<task_id>/` 表示。
- **Task Definition**：`task.md`，包含 frontmatter（元数据）+ 正文（要执行的指令/流程）。
- **Run**：一次任务执行；目录 `./.ship/task/<task_id>/<timestamp>/`。
- **Scheduler**：cron 调度器；读取 `task.md` 的 `cron`，在运行时触发对应 `run`。
- **Runner**：执行器；把任务正文提交给 Agent，产出可审计的 history 与结果摘要。

## 5. 目录结构（Disk Layout）

在项目根目录下：

```text
./.ship/task/
  <task_id>/
    task.md
    <timestamp>/
      history.jsonl
      input.md
      output.md
      result.md
      error.md               (optional)
      *.md                   (optional, 过程文件/记录文件)
```

约束：

- `task.md` 必须存在
- `<timestamp>` 推荐格式：`YYYYMMDD-HHmmss-SSS`（可排序且文件系统友好）
- `history.jsonl` 为执行过程中“干净历史”的唯一事实源（run 级别）

## 6. Task Definition：`task.md` 规范

### 6.1 Frontmatter（必须字段）

`task.md` 必须包含 YAML frontmatter，且以下字段必须存在：

- `title`：string，任务标题
- `cron`：string，cron 表达式（建议采用 node-cron 兼容的 5 字段格式：`min hour dom mon dow`）
  - 若需要“仅手动执行”的任务：使用 `cron: "@manual"`（仍满足“必须有 cron 字段”）
- `description`：string，任务描述（用于列表/检索/提示词展示）
- `chatKey`：string，结果发送目标（与现有 ChatRuntime/adapter 的 chatKey 一致）
- `status`：string，任务状态（建议枚举：`enabled | paused | disabled`）

建议可选字段（非必须，但利于后续扩展）：

- `timezone`：string，例如 `Asia/Shanghai`（若未提供，默认使用服务器本地时区）
- `maxRetries`：number，默认 0
- `timeoutMs`：number，默认 0（不超时）
- `notifyOn`：string[]，例如 `["success","failure"]`（默认都通知）

### 6.2 正文（任务正文）

frontmatter 之后的 markdown 正文就是“要执行的指令”。Runner 会把它作为本次 run 的输入，拼接最小系统提示后提交给 Agent。

正文建议结构：

- 背景/目标
- 输入/约束（如必须用哪些 tools）
- 步骤（可复用 skills_load）
- 输出格式要求（例如输出 `result.md` 的结构）

## 7. Run 行为（执行语义）

### 7.1 触发

- Scheduler 定时触发：当 `status=enabled` 且 `cron != "@manual"` 时生效
- 手动触发：`run_task` 工具（或未来 CLI）可直接创建一个 run 并执行

### 7.2 干净历史

每次 run 必须以“干净的历史”启动：

- 不读取用户对话历史（不使用 `.ship/chat/<chatKey>/...` 作为输入）
- 允许注入最小系统（例如 `Agent.md` + runtime 默认 prompts + tasks 相关系统约束）
- 允许注入 skills 摘要/已 pinned skills（如果未来要支持）

> 关键点：run 的历史文件只写入 `./.ship/task/<task_id>/<timestamp>/history.jsonl`，不污染常规 chat history。

### 7.3 过程文件

Runner 在 run 目录生成：

- `input.md`：本次 run 的任务正文快照（可包含解析后的 frontmatter 摘要）
- `output.md`：Agent 的最终输出（原样）
- `result.md`：面向人类的摘要（包含状态、耗时、关键产物、引用文件）
- `error.md`：失败时的错误摘要（可选）
- 其它 `*.md`：工具/步骤产物（例如抓取内容、分析报告等）

### 7.4 结果推送（chatKey）

run 完成（成功或失败）后，Runner 需要向 `task.md.chatKey` 发送消息：

- 必须包含：taskId、title、runTimestamp、status、result 摘要
- 必须包含可追溯路径：`./.ship/task/<task_id>/<timestamp>/result.md`
- 若失败：包含 error 摘要与下一步建议（例如查看 `error.md`）

推送方式：

- 推荐直接复用现有 egress（与 `chat_send` 相同的 dispatcher），由 Runner 在 server/runtime 中调用
- 不建议在 tool 内直接“刷消息”，而是集中在 Runner 的后处理阶段

## 8. API/工具设计（Tools）

新增内置工具（命名可微调，但建议与 PRD 保持一致）：

### 8.1 `create_task`

用途：创建一个 task 目录与 `task.md` 模板。

输入：

- `taskId`（可选；缺省则自动生成）
- `title`、`description`、`cron`、`chatKey`、`status`
- `body`（可选；缺省写入模板正文）

输出：

- `taskId`
- `taskPath`（相对 project root）
- `taskMdPath`

### 8.2 `task_list`

用途：列出所有 task 的摘要（读取 `task.md` frontmatter）。

输出字段：

- `taskId`
- `title`
- `description`
- `cron`
- `status`
- `chatKey`
- `lastRunAt`（若存在）
- `lastRunStatus`（若存在）

### 8.3 `run_task`

用途：手动触发执行（立即创建 run 目录并运行）。

输入：

- `taskId`
- `reason`（可选；写入 run 的元数据）

输出：

- `runTimestamp`
- `runDir`
- `status`

> 说明：`run_task` 应当复用与 scheduler 触发一致的 Runner 路径，保证行为一致。

## 9. 模块化设计（Independent Module）

建议新增独立模块：`package/src/core/task-system/`（目录名可讨论，但要独立于 core/runtime 与 core/tools）。

模块边界（建议）：

1) `model.ts`
- Task frontmatter 类型、状态枚举、解析/序列化
- 使用现有 frontmatter 解析器（与 skills 一致）或复用同一实现

2) `paths.ts`
- `getTaskRoot(projectRoot): string` -> `./.ship/task`
- `getTaskDir(taskId)` / `getTaskMdPath(taskId)` / `getRunDir(taskId, timestamp)`

3) `store.ts`
- `listTasks()`：扫描目录，读取 frontmatter
- `readTask(taskId)`：读取并返回 task + body
- `writeTask(task)`：创建/更新 task.md
- `createRun(taskId)`：创建 run 目录并写 `input.md`

4) `scheduler.ts`
- 基于 `node-cron` 注册 jobs
- 支持热重载策略（启动时加载；未来可加入文件监听）
- 负责触发 `runner.runTaskNow(...)`

5) `runner.ts`
- `runTaskNow(taskId, trigger)`：创建 runDir -> 调用 Agent -> 写 output/result -> 推送 chatKey
- 需要与现有 Agent 执行“逻辑一致”：复用同样的 toolset、同样的 request-context/telemetry
- 但 historyStore 必须切换到 run 目录（task run history）

6) `tools.ts`（或直接在 `core/tools/builtin/task.ts`）
- 只做参数校验与调用 store/runner，不直接实现复杂业务

> 关键点（中文）：实现上可以通过“task-run 专用 chatKey”把 history 写入 runDir。
> - 约定 run chatKey：`task-run:<taskId>:<timestamp>`
> - ChatRuntime.getHistoryStore 识别该前缀后，创建一个 ChatHistoryStore，并把 messagesDir 直接指向 `./.ship/task/<taskId>/<timestamp>/`（history.jsonl/meta.json/archive/ 都落在 runDir 内）
> - Agent 在 run 时统一从 ChatRuntime 获取 historyStore，从而无需复制 `.ship/chat/*` 目录

## 10. 调度与并发策略

### 10.1 并发控制

建议默认：

- 同一 `taskId` 串行：避免同一个 task 重叠执行
- 不同 task 可并发，但有全局上限（例如 1～2），避免占满资源

实现方式：

- `TaskScheduler` 内部维护一个简单队列/信号量（可复用现有 chatQueue 的思想，但独立于 chatKey）

### 10.2 启动加载

在 `shipmyagent start` 初始化 runtime context 时：

- 读取 `./.ship/task/*/task.md`
- 对 `enabled` 的任务注册 cron
- 在 logger 中输出注册概览（多少任务、多少启用）

## 11. 可观测性与审计

必须保证以下信息可追溯：

- task 定义（`task.md`）
- run 输入（`input.md`）
- run 历史（`history.jsonl`）
- run 输出与摘要（`output.md` / `result.md` / `error.md`）
- 推送消息内容（建议写入 `result.md` 的 notify section）

## 12. 安全与权限

- task 可能调用 `exec_shell`、写 repo 文件等；应沿用现有 permissions 机制（例如需要 approval 的 exec_shell）
- 建议在 task runner 的 system prompt 中明确：
  - 只能在项目目录操作
  - 不能泄露敏感信息
  - 输出要可审计（写到 run 目录）

## 13. 里程碑（实施阶段建议）

Phase 1（MVP）
- 目录结构 + `task.md` frontmatter 校验
- `task_list` / `create_task` / `run_task`
- Runner：干净历史执行 + 写 run 目录 + 推送 chatKey（先只发最小文本）
- Scheduler：node-cron 定时触发 enabled tasks

Phase 2（增强）
- lastRunAt/lastStatus 写回 task.md frontmatter
- 失败重试/超时
- 更丰富的 result 模板
- 文件监听热重载任务定义
